---
title: 记项目中接触Https的经历
date: 2020-03-13 11:17:50
tags:
categories:
---

前两天遇到一个有意思的经历，故记录一下。

描述：  

大晚上的，Android客户端一切请求都失败了，而IOS却没问题。故电话要我解决问题。（习惯了这个规律，若两个移动端，仅有一方
出现问题，立即推 > 前端的锅）    
翻身起床，打开电话查看日志，果真发现所有的请求都抛了这个异常：
```
javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found.
```
初看一眼,`net`,`SSLHandshakeException`,`certification`,这些关键词告诉我，这显然是后端的问题哈~  
自然地将这个错误复制搜索，果不其然，已有[前车之鉴](https://blog.csdn.net/MoonLoong/article/details/79760428)，

>问题原因：
 由于项目的https.bks证书不是正规的CA签发的证书，而是二级代理商等签发的证书，验证不通过造成的  
 解决方案：  
 方案一：  
 获取正规合法的https证书，让后台上传或者存在assets中，进行应用验证，这是最根本的解决办法  
 方案二：  
 忽略https的证书校验  

果不其然，后台今天使用第三方服务加速服务，迁移了服务器，导致了这个问题。试图使用方案一，可是后端说自己的服务器证书正常，而且IOS没问题，
故需Android改。  

解决问题：  
按引用博客里面说的，思路是忽略https证书验证，但其博客仅是在Application中忽略，要对OkHttpClient生效的，需这样：  
```kotlin
        val xtm: X509TrustManager = object : X509TrustManager {
            override fun checkClientTrusted(
                chain: Array<X509Certificate?>?,
                authType: String?
            ) {
            }

           override fun checkServerTrusted(
                chain: Array<X509Certificate?>?,
                authType: String?
            ) {
            }

            override fun getAcceptedIssuers(): Array<X509Certificate> {
                return arrayOf()
            }
        }

        var sslContext: SSLContext? = null
        try {
            sslContext = SSLContext.getInstance("SSL")
            sslContext.init(null, arrayOf<TrustManager>(xtm), SecureRandom())
        } catch (e: NoSuchAlgorithmException) {
            e.printStackTrace()
        } catch (e: KeyManagementException) {
            e.printStackTrace()
        }
        val DO_NOT_VERIFY: HostnameVerifier = object : HostnameVerifier {
            override fun verify(hostname: String?, session: SSLSession?): Boolean {
                return true
            }
        }
        instance<OkHttpClient.Builder>()
            .sslSocketFactory(sslContext?.socketFactory)
            .hostnameVerifier(DO_NOT_VERIFY)
            ...
```
另，因为项目中部分页面内嵌WebView的，而WebView也要需做忽略配置：  
```kotlin
 webViewClient = object : WebViewClient() {
                override fun onReceivedSslError(
                    view: WebView?,
                    handler: SslErrorHandler?,
                    error: SslError?
                ) {
                    handler?.proceed()
                }
            }
```

自此，问题解决了。下一篇总结自己最近学习的网络知识。  



