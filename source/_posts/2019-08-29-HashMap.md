---
title: HashMap
date: 2019-08-29 18:03:43
tags:
categories:
---

>  Map > AbstractMap > HashMap  


## Map

翻译：  

一个键值对的集合。 一个map不能包括重复的key，一个key最多对应一个值。（即通过一个key最多能找到一个值，包括没有值的情况）  

这个接口是用来替换的`Dictionary`类，因为`Dictionary`是一个抽象类，而不是一个接口。  


Map提供了三种观察集合的方式，包括：
1. a set of keys    键的集合
2. collection of values 值的集合
3. set of key-value mappings    键值对的集合  

遍历map的顺序，定义为，迭代map并返回集合元素的顺序。每次迭代，得到元素的序列。在具体实现上，每次遍历`TreeMap`返回的序列顺序是唯一，而`HashMap`
则不唯一。  

在key是可变的变量（即不用`final`修饰的变量）时，若是该变量的指向对象改变，Map是没有对该行为负责的。（尽量不要使用final的元素作为key）。
Map中是不允许用自身作为它的一个key；若是把自身作为其中一个value，则在比较对象的是否相等的可靠性也不可保证。


通常的Map的实现都提供两个构造方法，一个无参的，一个Map（Map），接受一个map作为参数来作为初始元素。当然这只是个建议，接口没有强制这个建议
手段，但是JDK的中的实现都遵循了这个建议。


有一些方法是没有具体实现的，所以抛出支持该操作的异常。


一个Map的实现，可能会对KEY和Value的类型做限制。比如允许key-value为空的，或对键的类型做限制。不顾这些限制会可能抛出异常。

很多集合框架，都会要求比较的两个对象是非空类型，这里Map不做要求。


一些操作会有'self-referential'的情形，在遍历这个集合时，无论是直接或间接`引用自身`，有可能要特殊处理。


```java
public interface Map<K,V>{
    int size();
    boolean isEmpty();
    boolean containKey(Object key);
    boolean containValue(Object value);
    V get(Object key);
    V put(K key, V value);
    void putAll( Map<? extends K,? extends V> m);
    void clear();
    //下面三个即上面提到的是三种视图。
    Set<K> keySet();
    Collection<V> values();
    Set<Map.Entry<K,V>> entrySet();
    
    interface Entry<K,V>{
        K getKey();
        V getValue();
        V setValue(V value);
        boolean equal(Object o);
        int hashCode();
        
            //...一些比较实现，根据Key或Value来排序，或是通过Lamda来暴露比较的算法。
        public static <K extends Comparable<? super K>,V> Comparator<Map.Entry<K,V>> comparingByKey(){}
    }
    
    
    //通过方法，看到Java8提供了default关键字，让接口也能实现方法，（包括声明成员，如下），包括提供了lamda，使得函数也能作为参数。
//    default int value=10;
    default void forEach(BiCosumer<? super Key,? super V> action);
    //... remove(), replace(),merge()操作
    
}
```


## AbstractMap

翻译：  

这个类提供了对`Map`提供了骨架的实现，减轻了子类对Map实现的负担。


要是实现一个不可变的Map，（unmodifiable map），只要继承该类并实现`entrySet()`方法，也就没有`add`，`remove`方法的具体实现，若是调用了直接报异常。
实现一个可变的Map，就要实现`add()`, `remove()`方法了，并且在它的迭代器要同时实现添加移除的方法。

```java
public abstract class AbstractMap<K,V> implements Map<K,V>{
    //查询操作
    //size(),isEmpty(),containValues(),containKey() get()
    //比如：
    public V get(Object key){
        Iterator<Entry<K,V>> i = entrySet().iterator();
        if(key==null){      //key为null的情况
            while(i.hasNext()){     //先通过hasNext()方法判断在该游标之后是是否仍有元素, 再通过.next()方法获取该元素。
                Entry<K,V> e = i.next();
                if(e.getKey()==null){
                    return e.getValue();
                }
            }
        }else{  //key非空的情况
            while(i.hasNext()){ 
                Entry<K,V> e = i.next();
                if(key.equals(e.getKey())){
                    return e.getValue();
                }
            }
        }
    }
    
    //修改操作
    //put(),remove()
    
    //Bulk Operation批量操作
    //putAll(),  clear()
    
    //Views 查看
    transient Set<K> keySet;
    transient Collection<V> values;
    //keySet(),values(),entrySet()，注意这里的entrySet（）方法是抽象方法。
    
    //Comparing and hashing 一些比较，哈希方法的实现
    
}

```

## HashMap

翻译：  

使用了哈希表来实现了`Map`接口。实现了所有可选的方法，允许key和value为空的情况。
`HashMap`类似`HashTable`，不同之处在于`HashMap`不同步的，且允许null的情况。由于使用Hash表实现的方式，所以遍历是出来的元素顺序不保证相同。


HashMap的在对元素`get`，`put`操作时，提供了常量时的性能（时间复杂度为O(1)），前提是哈希函数能够将元素合理地分散在桶子里。（愿译：assuming the
has function disperses the elements properly among buckets.） 遍历集合视图（即遍历所有元素）需要时间复杂度n（n=桶子的数量+
所有链表的元素size之和）。所以在设置初始容量（initial capacity）或是加载因子太低（the load factory）,否则遍历性能会很低。


HashMap有两个参数会决定它的性能，初始容量和加载因子。初始容量就是在在哈希表创建时，桶子的数量，加载因子是表示哈希表多满时
（即装元素的桶子数目/所有桶子数目），容量会自动增加。